//#############################################################################
//
// FILE:  psfbpcmc.h
//
// TITLE: solution hardware abstraction layer header file
//        This file consists of common variables and functions
//        for a particular hardware board, like functions to read current
//        and voltage signals on the board and functions to setup the
//        basic peripherals of the board
//
//#############################################################################
// $TI Release: TIDM_02000 v1.01.03.00 $
// $Release Date: Tue Jun 25 11:22:24 CDT 2024 $
// $Copyright:
// Copyright (C) 2024 Texas Instruments Incorporated - http://www.ti.com/
//
// ALL RIGHTS RESERVED
// $
//#############################################################################

#ifndef PSFBPCMC_H
#define PSFBPCMC_H


#ifdef __cplusplus

extern "C" {
#endif

//
// the includes
//
#include <stdint.h>

#ifndef __TMS320C28XX_CLA__
#include <math.h>
#else
#include <CLAmath.h>
#endif

//
// this is the file generated by the powerSUITE page for this system
//
#include "psfbpcmc_settings.h"
#include "psfbpcmc_hal.h"

//
// Library header files
// DCL Library is used for the controller implementation
// GV -> DCL_DF22 for voltage loop (gv),
//
#ifndef __TMS320C28XX_CLA__
#include "DCLF32.h"
//#define GV_STRUCT   DCL_DF22
//#define GV_RUN1     DCL_runDF22_C2
//#define GV_RUN2     DCL_runClamp_C1
//#define GV_RUN3     DCL_runDF22_C3
#else
#include "DCLCLA.h"
//#define GV_STRUCT   DCL_DF22_CLA
//#define GV_RUN1     DCL_runDF22_L2
//#define GV_RUN2     DCL_runClamp_L1
//#define GV_RUN3     DCL_runDF22_L3

//#pragma FUNC_ALWAYS_INLINE(DCL_runDF22_L4)
#endif


#ifndef __TMS320C28XX_CLA__
#include "sfra_f32.h"
#include "sfra_gui_scicomms_driverlib.h"
#define PSFB_SFRA_INJECT SFRA_F32_inject
#define PSFB_SFRA_COLLECT SFRA_F32_collect
#else
#define PSFB_SFRA_INJECT(m)    m
#define PSFB_SFRA_COLLECT(m, n)
#endif

//
//globals
//
enum PSFB_enum_BuildLevel {
    BuildLevel1_OpenLoop = 0,
    BuildLevel2_VoltageLoop = 1,
};

enum PSFB_enum_boardState {
    boardState_OFF = 0,
    boardState_CheckInput = 1,
    boardState_PowerStageON = 2,
    boardState_TripCondition = 3,
};

enum PSFB_enum_boardStatus {
    boardStatus_Idle = 0,
    boardStatus_NoFault = 1,
    boardStatus_OverCurrentTrip = 2,
    boardStatus_EmulatorStopTrip = 3,
    boardStatus_OverVoltageTrip = 4,
};

extern volatile enum PSFB_enum_boardState PSFB_boardState;
extern volatile enum PSFB_enum_BuildLevel PSFB_BuildInfo;
extern volatile enum PSFB_enum_boardStatus PSFB_boardStatus;

//
// voltage controller
//
#ifndef __TMS320C28XX_CLA__
extern DCL_DF22 PSFB_gv;
#else
extern DCL_DF22_CLA PSFB_gv;
#endif


extern float32_t PSFB_cntlMax, PSFB_cntlMin;
extern uint16_t PSFB_saturation_flag;
extern float32_t PSFB_saturation_flag_CLA;

extern uint16_t PSFB_guiPowerStageStart;
extern uint16_t PSFB_guiPowerStageStop;


#ifndef __TMS320C28XX_CLA__
//
//--- SFRA Related Variables ----
//
extern float32_t PSFB_plantMagVect[PSFB_SFRA_FREQ_LENGTH];
extern float32_t PSFB_plantPhaseVect[PSFB_SFRA_FREQ_LENGTH];
extern float32_t PSFB_olMagVect[PSFB_SFRA_FREQ_LENGTH];
extern float32_t PSFB_olPhaseVect[PSFB_SFRA_FREQ_LENGTH];
extern float32_t PSFB_freqVect[PSFB_SFRA_FREQ_LENGTH];

extern SFRA_F32 PSFB_sfra1;
#endif

extern float32_t PSFB_adc_noise;
extern float32_t PSFB_H_calc;
extern float32_t PSFB_error_bound;
extern float32_t PSFB_inj_calculated;

//
// Output Voltage measurement
//
extern volatile float32_t PSFB_vLVBus_sensed_pu, PSFB_vLVBus_Volts;
extern volatile float32_t PSFB_vBus_sensedOffset_pu;

//
// peak current loop set-point
//
extern float32_t PSFB_icommand_Set_pu, PSFB_gui_icommand_Set_Amps;
extern volatile float32_t PSFB_irampmax_Set;
extern volatile float32_t PSFB_vcommand_Set_pu, PSFB_error_vLVBus_pu;

//
// Display Values
//
extern float32_t PSFB_guiLVbus_Volts;
extern float32_t PSFB_guiHVbus_Volts;
extern float32_t PSFB_guiIHV_Amps;

extern volatile float32_t PSFB_guivLVBus_SlewedSet_Volts,
                          PSFB_guivLVBus_Set_Volts;
extern volatile float32_t PSFB_guivLVBus_initial_Volts;

extern volatile float32_t PSFB_gui_ovpThreshold_Volts;

extern uint16_t PSFB_PhaseShift;

//
// Synchronous Rectification
//
extern int16_t PSFB_sr_enable;

//
// per unit duty value
//
extern volatile float32_t PSFB_dutyPU;

//
// Flags for clearing trips and closing the loops and the Relay
//
extern volatile int16_t PSFB_closeGiLoop, PSFB_closeGvLoop,
                        PSFB_clearTrip, PSFB_rlyConnect;

extern volatile float32_t PSFB_gv_out;

//
// sets a limit on the amount of external GUI controls
//
extern volatile int16_t *varSetTxtList[16];
extern volatile int16_t *varSetBtnList[16];
extern volatile int16_t *varSetSldrList[16];
extern volatile int16_t *varGetList[16];
extern volatile int32_t *arrayGetList[16];
extern volatile uint32_t *dataSetList[16];

extern volatile float32_t PSFB_vBusSensedBuff[10];
extern volatile float32_t PSFB_vBus_sensedFiltered_pu;
extern volatile int16_t PSFB_vBusSensedBuffIndex;

extern volatile int16_t PSFB_start_flag, PSFB_count_ovp;
extern volatile int16_t PSFB_ovp_Fault, PSFB_ocp_Fault;

//
// the function prototypes
//

#ifndef __TMS320C28XX_CLA__
#ifdef FLASH
#pragma CODE_SECTION(ISR1,"ramfuncs");
#endif
#pragma INTERRUPT (ISR1, HPI)
interrupt void ISR1(void);

static inline void PSFB_HAL_clearInterrupt(uint16_t pie_group_no);
static inline void PSFB_HAL_setupInterrupt(void);
#endif

#ifndef __TMS320C28XX_CLA__
    extern void PSFB_setupSFRA();
    extern void PSFB_runSFRABackGroundTasks();
#else
#endif

void PSFB_OVP();
void PSFB_EnablePSFBPWM();
void PSFB_UpdateRampSlope();
void PSFB_UpdateOCPThreshold();
void PSFB_SoftStart();
void PSFB_StartupControl();
void PSFB_globalVariablesInit();

#pragma FUNC_ALWAYS_INLINE(PSFB_pcmcControlCode)

//
// Control Code
//
static inline void PSFB_pcmcControlCode(void)
{
    int k = 0;

    //
    // Read Current and Voltage Measurements
    //
    PSFB_vLVBus_sensed_pu = ((float32_t)(PSFB_LVBUS_FB))
                            * PSFB_ADC_PU_SCALE_FACTOR;
    PSFB_vLVBus_Volts = PSFB_vBus_sensedFiltered_pu
                        * PSFB_VLVBUS_MAX_SENSE_VOLTS;
//
// Open Loop
//
#if PSFB_INCR_BUILD == 1
    PSFB_icommand_Set_pu = PSFB_SFRA_INJECT(PSFB_gui_icommand_Set_Amps /
                                           (PSFB_IHV_FILT_MAX_SENSE_AMPS));
#endif

//
// Closed Voltage Loop
//
#if PSFB_INCR_BUILD == 2

    PSFB_vcommand_Set_pu = PSFB_SFRA_INJECT(PSFB_guivLVBus_SlewedSet_Volts /
                                           (PSFB_VLVBUS_MAX_SENSE_VOLTS));

    PSFB_error_vLVBus_pu = PSFB_vcommand_Set_pu - PSFB_vLVBus_sensed_pu;

//
// run compensator
//
#if PSFB_CONTROL_RUNNING_ON == C28x_CORE
    PSFB_icommand_Set_pu = DCL_runDF22_C2 (&PSFB_gv, PSFB_error_vLVBus_pu);
    PSFB_saturation_flag = DCL_runClamp_C1(&PSFB_icommand_Set_pu, PSFB_cntlMax,
                                           PSFB_cntlMin);
    if(0 == PSFB_saturation_flag)
    {
        DCL_runDF22_C3(&PSFB_gv, PSFB_error_vLVBus_pu, PSFB_icommand_Set_pu);
    }
#else
    PSFB_icommand_Set_pu = DCL_runDF22_L2(&PSFB_gv, PSFB_error_vLVBus_pu);
    PSFB_saturation_flag_CLA = DCL_runClamp_L1(&PSFB_icommand_Set_pu,
                                               PSFB_cntlMax, PSFB_cntlMin);
    if(0.0f == PSFB_saturation_flag_CLA)
    {
        DCL_runDF22_L3(&PSFB_gv, PSFB_error_vLVBus_pu, PSFB_icommand_Set_pu);
    }
#endif

    //
    // Clamp max/min
    //
    PSFB_icommand_Set_pu = (PSFB_icommand_Set_pu > PSFB_cntlMax)?
                            PSFB_cntlMax:PSFB_icommand_Set_pu;
    PSFB_icommand_Set_pu = (PSFB_icommand_Set_pu < PSFB_cntlMin)?
                            PSFB_cntlMin:PSFB_icommand_Set_pu;

#endif

    if(PSFB_icommand_Set_pu < 0)
    {
        PSFB_irampmax_Set = 0;
    }
    else
    {
        PSFB_irampmax_Set = PSFB_icommand_Set_pu * (PSFB_IRAMPMAX_SET_RATIO);
    }
    CMPSS_setMaxRampValue(PSFB_PCMC_OCP_CMPSS_BASE, (int16_t)PSFB_irampmax_Set);

//
// Open Loop Check
//
#if PSFB_INCR_BUILD == 1
    PSFB_SFRA_COLLECT((float32_t *)&PSFB_icommand_Set_pu,
                      (float32_t *)&PSFB_vLVBus_sensed_pu);
#endif

#if PSFB_INCR_BUILD == 2
    PSFB_SFRA_COLLECT((float32_t *)&PSFB_icommand_Set_pu,
                      (float32_t *)&PSFB_vLVBus_sensed_pu);
#endif

    PSFB_vBusSensedBuff[PSFB_vBusSensedBuffIndex++] = PSFB_vLVBus_sensed_pu;
    if(PSFB_vBusSensedBuffIndex >= 10)
    {
        PSFB_vBusSensedBuffIndex = 0;
    }

    PSFB_vBus_sensedFiltered_pu = 0;

    for(k = 0; k < 10; k++)
    {
        PSFB_vBus_sensedFiltered_pu += PSFB_vBusSensedBuff[k];
    }

    PSFB_vBus_sensedFiltered_pu = PSFB_vBus_sensedFiltered_pu * 0.1;

    if(PSFB_sr_enable == 1)
    {
        if(PSFB_SR_mode == 1)
        {
            //
            // BasexA output
            // CTR = PRD , set to 1
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                    EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_TIMEBASE_PERIOD);

            //
            // CTR = ZERO , set to 0
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                    EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO);

            //
            // CTR = T1D , set to 0
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                    EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_T1_COUNT_DOWN);

            //
            // CTR = T1U , set to 0
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                    EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_T1_COUNT_UP);

            //
            // BasexB output
            // CTR = PRD , set to 1
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                    EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_TIMEBASE_PERIOD);

            //
            // CTR = ZERO , set to 0
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                    EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO);

            //
            // CTR = T1U , set to 1
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                    EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_T1_COUNT_UP);

            //
            // CTR = T1D , set to 1
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                    EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_T1_COUNT_DOWN);

        }
        else if(PSFB_SR_mode == 2)
        {
            //
            // BasexA output
            // CTR = PRD , set to 1
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                    EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_TIMEBASE_PERIOD);

            //
            // CTR = ZERO , set to 0
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                    EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO);

            //
            // CTR = T1U , set to 1
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                    EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_T1_COUNT_UP);

            //
            // CTR = T1D , set to 1
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                    EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_T1_COUNT_DOWN);

            //
            // BasexB output - Following 4 not needed if xB generated using DB
            // CTR = PRD , set to 1
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                    EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_TIMEBASE_PERIOD);

            //
            // CTR = ZERO , set to 0
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                    EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO);

            //
            // CTR = T1D , set to 0
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                    EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_T1_COUNT_DOWN);

            //
            // CTR = T1U , set to 0
            //
            EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                    EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_T1_COUNT_UP);

        }
    }
    else
    {
        //
        // BasexA output
        // CTR = PRD , set to 0
        //
        EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_TIMEBASE_PERIOD);

        //
        // CTR = ZERO , set to 0
        //
        EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO);

        //
        // CTR = T1U , set to 0
        //
        EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                EPWM_AQ_OUTPUT_LOW , EPWM_AQ_OUTPUT_ON_T1_COUNT_UP);

        //
        // CTR = T1D , set to 0
        //
        EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_A ,
                EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_T1_COUNT_DOWN);

        //
        // BasexB output - Following 4 not needed if xB generated using DB
        // CTR = PRD , set to 1
        //
        EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_TIMEBASE_PERIOD);

        //
        // CTR = ZERO , set to 1
        //
        EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO);

        //
        // CTR = T1D , set to 1
        //
        EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_T1_COUNT_DOWN);

        //
        // CTR = T1U , set to 1
        //
        EPWM_setActionQualifierAction(PSFB_SR_PWM_BASE, EPWM_AQ_OUTPUT_B ,
                EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_T1_COUNT_UP);


    }


}


#ifdef __cplusplus
}
#endif

#endif

